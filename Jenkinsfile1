pipeline {

 environment {
 MAVEN_HOME = '/usr'
 JAVA_HOME = '/usr'
 IMAGE_NAME = 'mycar'
 }
 
parameters {
        string (name: 'GIT_BRANCH',           defaultValue: 'master',  description: 'Git branch to build')
        booleanParam (name: 'DEPLOY_TO_PROD', defaultValue: false,     description: 'If build and tests are good, proceed and deploy to production without manual approval')

        // The commented out parameters are for optionally using them in the pipeline.
        // In this example, the parameters are loaded from file ${JENKINS_HOME}/parameters.groovy later in the pipeline.
        // The ${JENKINS_HOME}/parameters.groovy can be a mounted secrets file in your Jenkins container.
        string (name: 'DOCKER_REG',         defaultValue: 'sanjoy-testdockerrepo.jfrog.io',  description: 'Docker registry')
        string (name: 'DOCKER_TAG',         defaultValue: 'latest',                          description: 'Docker tag')
        string (name: 'DOCKER_USR',         defaultValue: 'admin',                           description: 'Your helm repository user')
        string (name: 'DOCKER_PSW',         defaultValue: 'Zu6Tv8Ik5Kq0Se',                  description: 'Your helm repository password')
      //string (name: 'IMG_PULL_SECRET',    defaultValue: 'dockerregcred',                   description: 'The Kubernetes secret for the Docker registry (imagePullSecrets)')
		string (name: 'KUBE_NAMESPACE',     defaultValue: 'dev',                             description: 'Your helm repository password')
}

agent { node { label 'master' } }

stages {

stage('Git clone and setup') {
steps{
git branch: "master",
url: 'https://github.com/sanju99sen/spring-maven-sample.git'

// Define a unique name for the tests container and helm release
    script {
		branch = GIT_BRANCH.replaceAll('/', '-').replaceAll('\\*', '-')
        ID = "${IMAGE_NAME}-${DOCKER_TAG}-${branch}"
        echo "Global ID set to ${ID}"
    }
				
}
}

stage('Connect to JFROG Artifactory Server') {
steps{
rtServer (id: "Artifactory-1", url: "https://sanjoy.jfrog.io/sanjoy", credentialsId: 'artifactoryCRED')
}
}

stage('Map to Artifactory Resolver and Deployer REPO') {
steps {
rtMavenResolver (id: 'Resolver-1', serverId: 'Artifactory-1', releaseRepo: 'virtualmavenrepo', snapshotRepo: 'virtualmavenrepo')
rtMavenDeployer (id: 'Deployer-1',  serverId: 'Artifactory-1', releaseRepo: 'testmavenrepo', snapshotRepo: 'testmavenrepo')
}
}

stage('Run MAVEN BUILD') {
steps{
rtMavenRun (tool: 'MAVEN_TOOL', pom: 'pom.xml', goals: 'install', resolverId: "Resolver-1", deployerId: "Deployer-1")
}
}

stage ('Build Image') {
steps {
echo "Building application and Docker image"
sh "sh build.sh --build --registry ${DOCKER_REG} --docker_usr ${DOCKER_USR} --docker_psw ${DOCKER_PSW} --namespace ${KUBE_NAMESPACE}"
}
}

stage('Test the Image locally') {
steps{

// Kill container in case there is a leftover
//sh "[ -z docker ps -a | grep ${ID} 2>/dev/null) ] || docker rm -f ${ID}"

sh label: '', script: '[ -z `docker ps -a | grep ${ID} 2>/dev/null` ] || docker rm -f ${ID}'

echo "Starting ${IMAGE_NAME} container"
sh "docker run --detach --name ${ID} --rm --publish ${TEST_LOCAL_PORT}:80 ${DOCKER_REG}/${IMAGE_NAME}:${DOCKER_TAG}"

    script {
            host_ip = sh(returnStdout: true, script: '/sbin/ip route | awk \'/default/ { print $3 ":${TEST_LOCAL_PORT}" }\'')
    }
}
}

stage ('Publish Image') {
steps {
echo "Publish docker image to Artifactory Docker Repo"
sh "sh build.sh --push --registry ${DOCKER_REG} --docker_usr ${DOCKER_USR} --docker_psw ${DOCKER_PSW} --namespace ${KUBE_NAMESPACE}"
}
}

stage ('Deploy to K8-Dev') {
steps {
echo "Deploy to K8-Dev"
sh "sh build.sh --deploy --registry ${DOCKER_REG} --docker_usr ${DOCKER_USR} --docker_psw ${DOCKER_PSW} --namespace ${KUBE_NAMESPACE}"
}
}

}
}
